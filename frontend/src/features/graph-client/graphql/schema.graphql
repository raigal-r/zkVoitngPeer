# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type Community {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: String!
    ipfsMetadata: String!
    members(first: Int = 100, orderBy: Member_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Member_filter): [Member!]!
    offers(first: Int = 100, orderBy: Offer_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Offer_filter): [Offer!]!
    owner: Bytes!
    stakingRequirement: BigInt!
    stakingToken: Bytes!
    transactionHash: Bytes!
}

type CommunityCreated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    ipfsMetadata: String!
    owner: Bytes!
    stakingRequirement: BigInt!
    stakingToken: Bytes!
    transactionHash: Bytes!
}

type Member {
    allTimeCollateral: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    community: Community!
    id: Bytes!
    stakedCollateral: BigInt!
    stakedReputation: BigInt!
    totalReputation: BigInt!
    trades: BigInt!
    transactionHash: Bytes!
}

type MemberJoinedCommunity {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    member: Bytes!
    transactionHash: Bytes!
}

type Offer {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    community: Community!
    communityId: BigInt!
    id: String!
    metadata: String!
    offerId: BigInt!
    offerStatus: String!
    owner: Bytes!
    reputationRequirement: BigInt!
    stakingRequirement: BigInt!
    transactionHash: Bytes!
}

type OfferAccepted {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    member: Bytes!
    offerId: BigInt!
    transactionHash: Bytes!
}

type OfferClosed {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    member: Bytes!
    offerId: BigInt!
    transactionHash: Bytes!
}

type OfferCreated {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    communityId: BigInt!
    id: Bytes!
    newOffer_communityId: BigInt!
    newOffer_metadata: String!
    newOffer_offerStatus: Int!
    newOffer_owner: Bytes!
    newOffer_reputationRequirement: BigInt!
    newOffer_stakingRequirement: BigInt!
    offerId: BigInt!
    transactionHash: Bytes!
}

type OwnershipTransferred {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    newOwner: Bytes!
    previousOwner: Bytes!
    transactionHash: Bytes!
}

type PeerLocalInitalized {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    erc20: Bytes!
    id: Bytes!
    transactionHash: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    collateralTokenReturned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): collateralTokenReturned
    collateralTokenReturneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: collateralTokenReturned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: collateralTokenReturned_filter
    ): [collateralTokenReturned!]!
    collateralTokenStaked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): collateralTokenStaked
    collateralTokenStakeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: collateralTokenStaked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: collateralTokenStaked_filter
    ): [collateralTokenStaked!]!
    communities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Community_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Community_filter
    ): [Community!]!
    community(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Community
    communityCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CommunityCreated
    communityCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CommunityCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CommunityCreated_filter
    ): [CommunityCreated!]!
    member(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Member
    memberJoinedCommunities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MemberJoinedCommunity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MemberJoinedCommunity_filter
    ): [MemberJoinedCommunity!]!
    memberJoinedCommunity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MemberJoinedCommunity
    members(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Member_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Member_filter
    ): [Member!]!
    offer(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Offer
    offerAccepted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferAccepted
    offerAccepteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferAccepted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferAccepted_filter
    ): [OfferAccepted!]!
    offerClosed(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferClosed
    offerCloseds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferClosed_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferClosed_filter
    ): [OfferClosed!]!
    offerCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferCreated
    offerCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferCreated_filter
    ): [OfferCreated!]!
    offers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Offer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Offer_filter
    ): [Offer!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
    peerLocalInitalized(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PeerLocalInitalized
    peerLocalInitalizeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PeerLocalInitalized_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PeerLocalInitalized_filter
    ): [PeerLocalInitalized!]!
    reputationTokenBurn(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReputationTokenBurn
    reputationTokenBurns(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReputationTokenBurn_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReputationTokenBurn_filter
    ): [ReputationTokenBurn!]!
    reputationTokenMint(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReputationTokenMint
    reputationTokenMints(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReputationTokenMint_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReputationTokenMint_filter
    ): [ReputationTokenMint!]!
    reputationTokenReturned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): reputationTokenReturned
    reputationTokenReturneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: reputationTokenReturned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: reputationTokenReturned_filter
    ): [reputationTokenReturned!]!
    reputationTokenStaked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): reputationTokenStaked
    reputationTokenStakeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: reputationTokenStaked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: reputationTokenStaked_filter
    ): [reputationTokenStaked!]!
}

type ReputationTokenBurn {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    burnAmount: BigInt!
    id: Bytes!
    transactionHash: Bytes!
}

type ReputationTokenMint {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    mintAmount: BigInt!
    transactionHash: Bytes!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    collateralTokenReturned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): collateralTokenReturned
    collateralTokenReturneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: collateralTokenReturned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: collateralTokenReturned_filter
    ): [collateralTokenReturned!]!
    collateralTokenStaked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): collateralTokenStaked
    collateralTokenStakeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: collateralTokenStaked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: collateralTokenStaked_filter
    ): [collateralTokenStaked!]!
    communities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Community_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Community_filter
    ): [Community!]!
    community(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Community
    communityCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CommunityCreated
    communityCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CommunityCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CommunityCreated_filter
    ): [CommunityCreated!]!
    member(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Member
    memberJoinedCommunities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MemberJoinedCommunity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MemberJoinedCommunity_filter
    ): [MemberJoinedCommunity!]!
    memberJoinedCommunity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MemberJoinedCommunity
    members(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Member_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Member_filter
    ): [Member!]!
    offer(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Offer
    offerAccepted(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferAccepted
    offerAccepteds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferAccepted_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferAccepted_filter
    ): [OfferAccepted!]!
    offerClosed(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferClosed
    offerCloseds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferClosed_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferClosed_filter
    ): [OfferClosed!]!
    offerCreated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OfferCreated
    offerCreateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OfferCreated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OfferCreated_filter
    ): [OfferCreated!]!
    offers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Offer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Offer_filter
    ): [Offer!]!
    ownershipTransferred(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferred
    ownershipTransferreds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferred_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferred_filter
    ): [OwnershipTransferred!]!
    peerLocalInitalized(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PeerLocalInitalized
    peerLocalInitalizeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PeerLocalInitalized_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PeerLocalInitalized_filter
    ): [PeerLocalInitalized!]!
    reputationTokenBurn(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReputationTokenBurn
    reputationTokenBurns(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReputationTokenBurn_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReputationTokenBurn_filter
    ): [ReputationTokenBurn!]!
    reputationTokenMint(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ReputationTokenMint
    reputationTokenMints(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ReputationTokenMint_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ReputationTokenMint_filter
    ): [ReputationTokenMint!]!
    reputationTokenReturned(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): reputationTokenReturned
    reputationTokenReturneds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: reputationTokenReturned_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: reputationTokenReturned_filter
    ): [reputationTokenReturned!]!
    reputationTokenStaked(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): reputationTokenStaked
    reputationTokenStakeds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: reputationTokenStaked_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: reputationTokenStaked_filter
    ): [reputationTokenStaked!]!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

type collateralTokenReturned {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    stakingRequirementReturned: BigInt!
    transactionHash: Bytes!
}

type collateralTokenStaked {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    stakingRequirementStaked: BigInt!
    transactionHash: Bytes!
}

type reputationTokenReturned {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    reputationRequirementReturned: BigInt!
    transactionHash: Bytes!
}

type reputationTokenStaked {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: Bytes!
    reputationRequirementStaked: BigInt!
    transactionHash: Bytes!
}

enum CommunityCreated_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    ipfsMetadata
    owner
    stakingRequirement
    stakingToken
    transactionHash
}

enum Community_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    ipfsMetadata
    members
    offers
    owner
    stakingRequirement
    stakingToken
    transactionHash
}

enum MemberJoinedCommunity_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    member
    transactionHash
}

enum Member_orderBy {
    allTimeCollateral
    blockNumber
    blockTimestamp
    community
    community__blockNumber
    community__blockTimestamp
    community__communityId
    community__id
    community__ipfsMetadata
    community__owner
    community__stakingRequirement
    community__stakingToken
    community__transactionHash
    id
    stakedCollateral
    stakedReputation
    totalReputation
    trades
    transactionHash
}

enum OfferAccepted_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    member
    offerId
    transactionHash
}

enum OfferClosed_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    member
    offerId
    transactionHash
}

enum OfferCreated_orderBy {
    blockNumber
    blockTimestamp
    communityId
    id
    newOffer_communityId
    newOffer_metadata
    newOffer_offerStatus
    newOffer_owner
    newOffer_reputationRequirement
    newOffer_stakingRequirement
    offerId
    transactionHash
}

enum Offer_orderBy {
    blockNumber
    blockTimestamp
    community
    communityId
    community__blockNumber
    community__blockTimestamp
    community__communityId
    community__id
    community__ipfsMetadata
    community__owner
    community__stakingRequirement
    community__stakingToken
    community__transactionHash
    id
    metadata
    offerId
    offerStatus
    owner
    reputationRequirement
    stakingRequirement
    transactionHash
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum OwnershipTransferred_orderBy {
    blockNumber
    blockTimestamp
    id
    newOwner
    previousOwner
    transactionHash
}

enum PeerLocalInitalized_orderBy {
    blockNumber
    blockTimestamp
    erc20
    id
    transactionHash
}

enum ReputationTokenBurn_orderBy {
    blockNumber
    blockTimestamp
    burnAmount
    id
    transactionHash
}

enum ReputationTokenMint_orderBy {
    blockNumber
    blockTimestamp
    id
    mintAmount
    transactionHash
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

enum collateralTokenReturned_orderBy {
    blockNumber
    blockTimestamp
    id
    stakingRequirementReturned
    transactionHash
}

enum collateralTokenStaked_orderBy {
    blockNumber
    blockTimestamp
    id
    stakingRequirementStaked
    transactionHash
}

enum reputationTokenReturned_orderBy {
    blockNumber
    blockTimestamp
    id
    reputationRequirementReturned
    transactionHash
}

enum reputationTokenStaked_orderBy {
    blockNumber
    blockTimestamp
    id
    reputationRequirementStaked
    transactionHash
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input CommunityCreated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [CommunityCreated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    ipfsMetadata: String
    ipfsMetadata_contains: String
    ipfsMetadata_contains_nocase: String
    ipfsMetadata_ends_with: String
    ipfsMetadata_ends_with_nocase: String
    ipfsMetadata_gt: String
    ipfsMetadata_gte: String
    ipfsMetadata_in: [String!]
    ipfsMetadata_lt: String
    ipfsMetadata_lte: String
    ipfsMetadata_not: String
    ipfsMetadata_not_contains: String
    ipfsMetadata_not_contains_nocase: String
    ipfsMetadata_not_ends_with: String
    ipfsMetadata_not_ends_with_nocase: String
    ipfsMetadata_not_in: [String!]
    ipfsMetadata_not_starts_with: String
    ipfsMetadata_not_starts_with_nocase: String
    ipfsMetadata_starts_with: String
    ipfsMetadata_starts_with_nocase: String
    or: [CommunityCreated_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    stakingRequirement: BigInt
    stakingRequirement_gt: BigInt
    stakingRequirement_gte: BigInt
    stakingRequirement_in: [BigInt!]
    stakingRequirement_lt: BigInt
    stakingRequirement_lte: BigInt
    stakingRequirement_not: BigInt
    stakingRequirement_not_in: [BigInt!]
    stakingToken: Bytes
    stakingToken_contains: Bytes
    stakingToken_gt: Bytes
    stakingToken_gte: Bytes
    stakingToken_in: [Bytes!]
    stakingToken_lt: Bytes
    stakingToken_lte: Bytes
    stakingToken_not: Bytes
    stakingToken_not_contains: Bytes
    stakingToken_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Community_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Community_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: String
    id_contains: String
    id_contains_nocase: String
    id_ends_with: String
    id_ends_with_nocase: String
    id_gt: String
    id_gte: String
    id_in: [String!]
    id_lt: String
    id_lte: String
    id_not: String
    id_not_contains: String
    id_not_contains_nocase: String
    id_not_ends_with: String
    id_not_ends_with_nocase: String
    id_not_in: [String!]
    id_not_starts_with: String
    id_not_starts_with_nocase: String
    id_starts_with: String
    id_starts_with_nocase: String
    ipfsMetadata: String
    ipfsMetadata_contains: String
    ipfsMetadata_contains_nocase: String
    ipfsMetadata_ends_with: String
    ipfsMetadata_ends_with_nocase: String
    ipfsMetadata_gt: String
    ipfsMetadata_gte: String
    ipfsMetadata_in: [String!]
    ipfsMetadata_lt: String
    ipfsMetadata_lte: String
    ipfsMetadata_not: String
    ipfsMetadata_not_contains: String
    ipfsMetadata_not_contains_nocase: String
    ipfsMetadata_not_ends_with: String
    ipfsMetadata_not_ends_with_nocase: String
    ipfsMetadata_not_in: [String!]
    ipfsMetadata_not_starts_with: String
    ipfsMetadata_not_starts_with_nocase: String
    ipfsMetadata_starts_with: String
    ipfsMetadata_starts_with_nocase: String
    members_: Member_filter
    offers_: Offer_filter
    or: [Community_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    stakingRequirement: BigInt
    stakingRequirement_gt: BigInt
    stakingRequirement_gte: BigInt
    stakingRequirement_in: [BigInt!]
    stakingRequirement_lt: BigInt
    stakingRequirement_lte: BigInt
    stakingRequirement_not: BigInt
    stakingRequirement_not_in: [BigInt!]
    stakingToken: Bytes
    stakingToken_contains: Bytes
    stakingToken_gt: Bytes
    stakingToken_gte: Bytes
    stakingToken_in: [Bytes!]
    stakingToken_lt: Bytes
    stakingToken_lte: Bytes
    stakingToken_not: Bytes
    stakingToken_not_contains: Bytes
    stakingToken_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input MemberJoinedCommunity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [MemberJoinedCommunity_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    member: Bytes
    member_contains: Bytes
    member_gt: Bytes
    member_gte: Bytes
    member_in: [Bytes!]
    member_lt: Bytes
    member_lte: Bytes
    member_not: Bytes
    member_not_contains: Bytes
    member_not_in: [Bytes!]
    or: [MemberJoinedCommunity_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Member_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    allTimeCollateral: BigInt
    allTimeCollateral_gt: BigInt
    allTimeCollateral_gte: BigInt
    allTimeCollateral_in: [BigInt!]
    allTimeCollateral_lt: BigInt
    allTimeCollateral_lte: BigInt
    allTimeCollateral_not: BigInt
    allTimeCollateral_not_in: [BigInt!]
    and: [Member_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    community: String
    community_: Community_filter
    community_contains: String
    community_contains_nocase: String
    community_ends_with: String
    community_ends_with_nocase: String
    community_gt: String
    community_gte: String
    community_in: [String!]
    community_lt: String
    community_lte: String
    community_not: String
    community_not_contains: String
    community_not_contains_nocase: String
    community_not_ends_with: String
    community_not_ends_with_nocase: String
    community_not_in: [String!]
    community_not_starts_with: String
    community_not_starts_with_nocase: String
    community_starts_with: String
    community_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Member_filter]
    stakedCollateral: BigInt
    stakedCollateral_gt: BigInt
    stakedCollateral_gte: BigInt
    stakedCollateral_in: [BigInt!]
    stakedCollateral_lt: BigInt
    stakedCollateral_lte: BigInt
    stakedCollateral_not: BigInt
    stakedCollateral_not_in: [BigInt!]
    stakedReputation: BigInt
    stakedReputation_gt: BigInt
    stakedReputation_gte: BigInt
    stakedReputation_in: [BigInt!]
    stakedReputation_lt: BigInt
    stakedReputation_lte: BigInt
    stakedReputation_not: BigInt
    stakedReputation_not_in: [BigInt!]
    totalReputation: BigInt
    totalReputation_gt: BigInt
    totalReputation_gte: BigInt
    totalReputation_in: [BigInt!]
    totalReputation_lt: BigInt
    totalReputation_lte: BigInt
    totalReputation_not: BigInt
    totalReputation_not_in: [BigInt!]
    trades: BigInt
    trades_gt: BigInt
    trades_gte: BigInt
    trades_in: [BigInt!]
    trades_lt: BigInt
    trades_lte: BigInt
    trades_not: BigInt
    trades_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OfferAccepted_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OfferAccepted_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    member: Bytes
    member_contains: Bytes
    member_gt: Bytes
    member_gte: Bytes
    member_in: [Bytes!]
    member_lt: Bytes
    member_lte: Bytes
    member_not: Bytes
    member_not_contains: Bytes
    member_not_in: [Bytes!]
    offerId: BigInt
    offerId_gt: BigInt
    offerId_gte: BigInt
    offerId_in: [BigInt!]
    offerId_lt: BigInt
    offerId_lte: BigInt
    offerId_not: BigInt
    offerId_not_in: [BigInt!]
    or: [OfferAccepted_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OfferClosed_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OfferClosed_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    member: Bytes
    member_contains: Bytes
    member_gt: Bytes
    member_gte: Bytes
    member_in: [Bytes!]
    member_lt: Bytes
    member_lte: Bytes
    member_not: Bytes
    member_not_contains: Bytes
    member_not_in: [Bytes!]
    offerId: BigInt
    offerId_gt: BigInt
    offerId_gte: BigInt
    offerId_in: [BigInt!]
    offerId_lt: BigInt
    offerId_lte: BigInt
    offerId_not: BigInt
    offerId_not_in: [BigInt!]
    or: [OfferClosed_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OfferCreated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OfferCreated_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newOffer_communityId: BigInt
    newOffer_communityId_gt: BigInt
    newOffer_communityId_gte: BigInt
    newOffer_communityId_in: [BigInt!]
    newOffer_communityId_lt: BigInt
    newOffer_communityId_lte: BigInt
    newOffer_communityId_not: BigInt
    newOffer_communityId_not_in: [BigInt!]
    newOffer_metadata: String
    newOffer_metadata_contains: String
    newOffer_metadata_contains_nocase: String
    newOffer_metadata_ends_with: String
    newOffer_metadata_ends_with_nocase: String
    newOffer_metadata_gt: String
    newOffer_metadata_gte: String
    newOffer_metadata_in: [String!]
    newOffer_metadata_lt: String
    newOffer_metadata_lte: String
    newOffer_metadata_not: String
    newOffer_metadata_not_contains: String
    newOffer_metadata_not_contains_nocase: String
    newOffer_metadata_not_ends_with: String
    newOffer_metadata_not_ends_with_nocase: String
    newOffer_metadata_not_in: [String!]
    newOffer_metadata_not_starts_with: String
    newOffer_metadata_not_starts_with_nocase: String
    newOffer_metadata_starts_with: String
    newOffer_metadata_starts_with_nocase: String
    newOffer_offerStatus: Int
    newOffer_offerStatus_gt: Int
    newOffer_offerStatus_gte: Int
    newOffer_offerStatus_in: [Int!]
    newOffer_offerStatus_lt: Int
    newOffer_offerStatus_lte: Int
    newOffer_offerStatus_not: Int
    newOffer_offerStatus_not_in: [Int!]
    newOffer_owner: Bytes
    newOffer_owner_contains: Bytes
    newOffer_owner_gt: Bytes
    newOffer_owner_gte: Bytes
    newOffer_owner_in: [Bytes!]
    newOffer_owner_lt: Bytes
    newOffer_owner_lte: Bytes
    newOffer_owner_not: Bytes
    newOffer_owner_not_contains: Bytes
    newOffer_owner_not_in: [Bytes!]
    newOffer_reputationRequirement: BigInt
    newOffer_reputationRequirement_gt: BigInt
    newOffer_reputationRequirement_gte: BigInt
    newOffer_reputationRequirement_in: [BigInt!]
    newOffer_reputationRequirement_lt: BigInt
    newOffer_reputationRequirement_lte: BigInt
    newOffer_reputationRequirement_not: BigInt
    newOffer_reputationRequirement_not_in: [BigInt!]
    newOffer_stakingRequirement: BigInt
    newOffer_stakingRequirement_gt: BigInt
    newOffer_stakingRequirement_gte: BigInt
    newOffer_stakingRequirement_in: [BigInt!]
    newOffer_stakingRequirement_lt: BigInt
    newOffer_stakingRequirement_lte: BigInt
    newOffer_stakingRequirement_not: BigInt
    newOffer_stakingRequirement_not_in: [BigInt!]
    offerId: BigInt
    offerId_gt: BigInt
    offerId_gte: BigInt
    offerId_in: [BigInt!]
    offerId_lt: BigInt
    offerId_lte: BigInt
    offerId_not: BigInt
    offerId_not_in: [BigInt!]
    or: [OfferCreated_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Offer_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Offer_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    community: String
    communityId: BigInt
    communityId_gt: BigInt
    communityId_gte: BigInt
    communityId_in: [BigInt!]
    communityId_lt: BigInt
    communityId_lte: BigInt
    communityId_not: BigInt
    communityId_not_in: [BigInt!]
    community_: Community_filter
    community_contains: String
    community_contains_nocase: String
    community_ends_with: String
    community_ends_with_nocase: String
    community_gt: String
    community_gte: String
    community_in: [String!]
    community_lt: String
    community_lte: String
    community_not: String
    community_not_contains: String
    community_not_contains_nocase: String
    community_not_ends_with: String
    community_not_ends_with_nocase: String
    community_not_in: [String!]
    community_not_starts_with: String
    community_not_starts_with_nocase: String
    community_starts_with: String
    community_starts_with_nocase: String
    id: String
    id_contains: String
    id_contains_nocase: String
    id_ends_with: String
    id_ends_with_nocase: String
    id_gt: String
    id_gte: String
    id_in: [String!]
    id_lt: String
    id_lte: String
    id_not: String
    id_not_contains: String
    id_not_contains_nocase: String
    id_not_ends_with: String
    id_not_ends_with_nocase: String
    id_not_in: [String!]
    id_not_starts_with: String
    id_not_starts_with_nocase: String
    id_starts_with: String
    id_starts_with_nocase: String
    metadata: String
    metadata_contains: String
    metadata_contains_nocase: String
    metadata_ends_with: String
    metadata_ends_with_nocase: String
    metadata_gt: String
    metadata_gte: String
    metadata_in: [String!]
    metadata_lt: String
    metadata_lte: String
    metadata_not: String
    metadata_not_contains: String
    metadata_not_contains_nocase: String
    metadata_not_ends_with: String
    metadata_not_ends_with_nocase: String
    metadata_not_in: [String!]
    metadata_not_starts_with: String
    metadata_not_starts_with_nocase: String
    metadata_starts_with: String
    metadata_starts_with_nocase: String
    offerId: BigInt
    offerId_gt: BigInt
    offerId_gte: BigInt
    offerId_in: [BigInt!]
    offerId_lt: BigInt
    offerId_lte: BigInt
    offerId_not: BigInt
    offerId_not_in: [BigInt!]
    offerStatus: String
    offerStatus_contains: String
    offerStatus_contains_nocase: String
    offerStatus_ends_with: String
    offerStatus_ends_with_nocase: String
    offerStatus_gt: String
    offerStatus_gte: String
    offerStatus_in: [String!]
    offerStatus_lt: String
    offerStatus_lte: String
    offerStatus_not: String
    offerStatus_not_contains: String
    offerStatus_not_contains_nocase: String
    offerStatus_not_ends_with: String
    offerStatus_not_ends_with_nocase: String
    offerStatus_not_in: [String!]
    offerStatus_not_starts_with: String
    offerStatus_not_starts_with_nocase: String
    offerStatus_starts_with: String
    offerStatus_starts_with_nocase: String
    or: [Offer_filter]
    owner: Bytes
    owner_contains: Bytes
    owner_gt: Bytes
    owner_gte: Bytes
    owner_in: [Bytes!]
    owner_lt: Bytes
    owner_lte: Bytes
    owner_not: Bytes
    owner_not_contains: Bytes
    owner_not_in: [Bytes!]
    reputationRequirement: BigInt
    reputationRequirement_gt: BigInt
    reputationRequirement_gte: BigInt
    reputationRequirement_in: [BigInt!]
    reputationRequirement_lt: BigInt
    reputationRequirement_lte: BigInt
    reputationRequirement_not: BigInt
    reputationRequirement_not_in: [BigInt!]
    stakingRequirement: BigInt
    stakingRequirement_gt: BigInt
    stakingRequirement_gte: BigInt
    stakingRequirement_in: [BigInt!]
    stakingRequirement_lt: BigInt
    stakingRequirement_lte: BigInt
    stakingRequirement_not: BigInt
    stakingRequirement_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input OwnershipTransferred_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [OwnershipTransferred_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    newOwner: Bytes
    newOwner_contains: Bytes
    newOwner_gt: Bytes
    newOwner_gte: Bytes
    newOwner_in: [Bytes!]
    newOwner_lt: Bytes
    newOwner_lte: Bytes
    newOwner_not: Bytes
    newOwner_not_contains: Bytes
    newOwner_not_in: [Bytes!]
    or: [OwnershipTransferred_filter]
    previousOwner: Bytes
    previousOwner_contains: Bytes
    previousOwner_gt: Bytes
    previousOwner_gte: Bytes
    previousOwner_in: [Bytes!]
    previousOwner_lt: Bytes
    previousOwner_lte: Bytes
    previousOwner_not: Bytes
    previousOwner_not_contains: Bytes
    previousOwner_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input PeerLocalInitalized_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [PeerLocalInitalized_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    erc20: Bytes
    erc20_contains: Bytes
    erc20_gt: Bytes
    erc20_gte: Bytes
    erc20_in: [Bytes!]
    erc20_lt: Bytes
    erc20_lte: Bytes
    erc20_not: Bytes
    erc20_not_contains: Bytes
    erc20_not_in: [Bytes!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [PeerLocalInitalized_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ReputationTokenBurn_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ReputationTokenBurn_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    burnAmount: BigInt
    burnAmount_gt: BigInt
    burnAmount_gte: BigInt
    burnAmount_in: [BigInt!]
    burnAmount_lt: BigInt
    burnAmount_lte: BigInt
    burnAmount_not: BigInt
    burnAmount_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [ReputationTokenBurn_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ReputationTokenMint_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ReputationTokenMint_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    mintAmount: BigInt
    mintAmount_gt: BigInt
    mintAmount_gte: BigInt
    mintAmount_in: [BigInt!]
    mintAmount_lt: BigInt
    mintAmount_lte: BigInt
    mintAmount_not: BigInt
    mintAmount_not_in: [BigInt!]
    or: [ReputationTokenMint_filter]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input collateralTokenReturned_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [collateralTokenReturned_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [collateralTokenReturned_filter]
    stakingRequirementReturned: BigInt
    stakingRequirementReturned_gt: BigInt
    stakingRequirementReturned_gte: BigInt
    stakingRequirementReturned_in: [BigInt!]
    stakingRequirementReturned_lt: BigInt
    stakingRequirementReturned_lte: BigInt
    stakingRequirementReturned_not: BigInt
    stakingRequirementReturned_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input collateralTokenStaked_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [collateralTokenStaked_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [collateralTokenStaked_filter]
    stakingRequirementStaked: BigInt
    stakingRequirementStaked_gt: BigInt
    stakingRequirementStaked_gte: BigInt
    stakingRequirementStaked_in: [BigInt!]
    stakingRequirementStaked_lt: BigInt
    stakingRequirementStaked_lte: BigInt
    stakingRequirementStaked_not: BigInt
    stakingRequirementStaked_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input reputationTokenReturned_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [reputationTokenReturned_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [reputationTokenReturned_filter]
    reputationRequirementReturned: BigInt
    reputationRequirementReturned_gt: BigInt
    reputationRequirementReturned_gte: BigInt
    reputationRequirementReturned_in: [BigInt!]
    reputationRequirementReturned_lt: BigInt
    reputationRequirementReturned_lte: BigInt
    reputationRequirementReturned_not: BigInt
    reputationRequirementReturned_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input reputationTokenStaked_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [reputationTokenStaked_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [reputationTokenStaked_filter]
    reputationRequirementStaked: BigInt
    reputationRequirementStaked_gt: BigInt
    reputationRequirementStaked_gte: BigInt
    reputationRequirementStaked_in: [BigInt!]
    reputationRequirementStaked_lt: BigInt
    reputationRequirementStaked_lte: BigInt
    reputationRequirementStaked_not: BigInt
    reputationRequirementStaked_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}
